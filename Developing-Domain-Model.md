# Developing Domain Model

## 클래스, 속성, 관계 식별

### 도메인 영역의 주요 개념(명사)를 식별



## 도메인 모델에 행위 추가하기

### 도메인 모델에 행위를 추가함으로써 도메인 모델에 생명력을 부여

### 도메인 모델의 행위를 결정하기 위해 도메인 모델의 책임(Responsibility)과 상호작용(Collaboration)을 식별

### 클래스의 책임

* 클래스가 아는 것(속성, 관계)
* 하는 것
* 결정하는 것

### 클래스의 상호작용

* 책임 수행을 위해 호출하는 다른 클래스들

### 책임과 상호작용을 식별하는 절차

* 요구사항(유스케이스, 유저스토리, UI 디자인) 분석을 통해 애플리케이션이 처리해야 하는 요구사항 식별
* 도메인 모델의 클라이언트(프리젠테이션티어 등)에게 도메인 모델을 노출하기 위한 모데인 모델의 인터페이스(타입, 메소드) 결정
* 해당 인터페이스를 각각의 요구사항을 고려하여 TDD 접근법으로 구현



## 요구사항 식별하기

### 초리해야 할 요구사항 식별/어떻게 응답할 지 결정

### UI 디자인, 유스케이스, 유저스토리 등을 분석

### 요구사항은 2가지 부분으로 구성

* 사용자 행위
* 사용자 행위 요청에 대한 애플리케이션의 응답 (책임)

### 애플리케이션의 책임은 2가지로 그룹핑

* 사용자 입력 검증, 값 계산, 데이터베이스 갱신
* 값 출력



## 메소드 식별하기

### 각 요청에 대해 2가지 메소드들이 존재

* 서비스 메소드
  * 사용자 요청 검증
  * 계산 수행
  * 데이터베이스 갱신
* 리포지터리 메소드
  * 출력을 위한 데이터 반환

### 도메인 모델의 클라이언트는 도메인 티어를 2번 호출

* 서비스 메소드 + 리포지터리 메소드



## TDD로 메소드 구현하기

### 대상 서비스 메소드에 대해 하나 이상의 테스트케이스를 작성하는 것으로 시작

* 각 테스트케이스는 서로 다른 상황을 재현하기 위해 다른 인자로 구성된다.

### Mock 객체를 이용

* Service Methods -> Repository Methods 순으로 구현 (top-down 방식)
* 구현을 하다가 발견되는 collaborator를 구현하기 위해 머리 속에서 context-switching이 일어날 필요가 없어 집중하면서 구현 가능



